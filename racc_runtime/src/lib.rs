/// Contains the supporting logic needed for applications that wish to use RACC-generated parsers.

use log::debug;
use std::fmt::Debug;

#[derive(Clone, Copy, Debug)]
pub enum PushTokenResult {
    Ok, // The token was consumed.
    SyntaxError,
}

/// The final result of parsing a stream of tokens.
///
/// This value is returned from the `ParserState::finish` method.
pub enum FinishParseResult<SymbolValue> {
    Accepted(SymbolValue),
    SyntaxError,
}

/// Contains references to the parsing tables (and related information) needed by parsers.
///
/// You generally should not need to deal with `ParserTables` directly.  Instead, app code
/// should use the generated 'get_parser_tables()' method.  Example:
/// //
/// // ```
/// //     grammar! {
/// //         ... grammar definition ...
/// //     }
/// //
/// //     fn main() {
/// //         let mut parser = ParserState::new(get_parser_tables());
/// //
/// //         for token in (...) {
/// //             parser.push_token(token);
/// //         }
/// //
/// //         match parser.finish() {
/// //             ...
/// //         }
/// //     }
/// // ```
pub struct ParserTables<SymbolValue: Debug, AppContext> {
    pub yyrindex: &'static [u16],
    pub yysindex: &'static [u16],
    pub yygindex: &'static [u16],
    pub yytable: &'static [u16],
    pub yydgoto: &'static [u16],
    pub yydefred: &'static [u16],
    pub yylhs: &'static [u16],
    pub yylen: &'static [u16],
    pub yycheck: &'static [u16],
    pub yyname: &'static [&'static str],
    pub yyfinal: usize,

    // for debugging
    pub yyrules: &'static [&'static str],

    pub reduce:
        fn(parser: &mut Vec<SymbolValue>, reduction: usize, ctx: &mut AppContext) -> SymbolValue,
}

/// An active instance of a parser.  This structure contains the state of a parsing state
/// machine, including the state stack and the value stack.
///
/// To create an instance of `ParserState`, use `ParserState::new` and pass it a `ParserTables` which
/// describes your application's grammar.
pub struct ParserState<SymbolValue: Debug, AppContext> {
    tables: ParserTables<SymbolValue, AppContext>,
    yystate: usize,
    value_stack: Vec<SymbolValue>,
    state_stack: Vec<usize>,
}

// The initial state for all parsers.
const INITIAL_STATE: usize = 0;

impl<SymbolValue: Debug, AppContext> ParserState<SymbolValue, AppContext> {
    /// Initializes a new `ParserState`, given the parsing tables that were generated by the
    /// `grammar!` syntax extension.  Use the `push_token` and `finish` methods to advance the
    /// state of the parser.  Use the `reset` method to reset the parser to its initial state.
    pub fn new(
        tables: ParserTables<SymbolValue, AppContext>,
    ) -> ParserState<SymbolValue, AppContext> {
        ParserState {
            tables: tables,
            yystate: INITIAL_STATE,
            value_stack: Vec::new(),
            state_stack: {
                let mut v = Vec::with_capacity(20);
                v.push(INITIAL_STATE);
                v
            },
        }
    }

    /// Resets this parser to its initial state, exactly as if `Parser::new` had been used to generate a
    /// new ParserState object.  There is no semantic difference between using `Parser::new` and using
    /// `reset()`.  The `reset()` parser may be more efficient, since it does not require freeing and
    /// reallocating the internal state tables.
    pub fn reset(&mut self) {
        self.yystate = INITIAL_STATE;
        self.value_stack.clear();
        self.state_stack.clear();
        self.state_stack.push(INITIAL_STATE);
    }

    fn yyreduce(&mut self, reduction: usize, ctx: &mut AppContext) {
        let len = self.tables.yylen[reduction] as usize;
        let lhs = self.tables.yylhs[reduction];

        debug!(
            "state {} reducing by rule {}, len={}, lhs={}",
            self.yystate, self.tables.yyrules[reduction], len, lhs
        );
        assert!(self.value_stack.len() >= len);
        assert!(self.state_stack.len() >= len);

        // Invoke the generated "reduce" method.  This method handles popping values from
        // parser.values_stack, and then executing the app-supplied code for this reduction.
        // Because the generated code handles popping items from the stack, it is not necessary
        // for us to consult a 'yylen' table here; that information is implicit.
        let old_values_len = self.value_stack.len();
        let reduce_value = (self.tables.reduce)(&mut self.value_stack, reduction, ctx);
        assert!(self.value_stack.len() + len == old_values_len);
        debug!(
            "    generated code popped {} values from value stack, new len = {}",
            old_values_len,
            self.value_stack.len()
        );
        // Push the value that represents the reduction of this rule (the LHS).
        debug!("    after pushing the result of the reduction, value_stack.len = {}, reduce_value={:?}", self.value_stack.len() + 1, reduce_value);
        self.value_stack.push(reduce_value);

        // pop states
        for _ in 0..len {
            self.state_stack.pop().unwrap();
        }
        let top_state = self.state_stack[self.state_stack.len() - 1] as usize;

        self.yystate = top_state;

        if top_state == 0 && lhs == 0 {
            debug!(
                "        after reduction, shifting from state 0 to state {} (0/0 case!)",
                self.tables.yyfinal
            );
            self.yystate = self.tables.yyfinal;
            self.state_stack.push(self.tables.yyfinal);

        // todo: port acceptance code
        } else {
            let yyn_0 = self.tables.yygindex[lhs as usize] as i16;
            let yyn_1 = yyn_0 + (self.yystate as i16);

            // debug!("        checking gindex, yym={}, yyn_0={}, yyn_1={}, YYCHECK[yyn_1]={}", lhs, yyn_0, yyn_1, self.tables.yycheck[yyn_1 as usize]);
            let next_state: usize =
                if (self.tables.yycheck[yyn_1 as usize] as usize) == self.yystate {
                    // debug!("        yystate = yytable[{}] = {}", yyn_1, self.tables.yytable[yyn_1 as usize]);
                    self.tables.yytable[yyn_1 as usize] as usize
                } else {
                    // debug!("         yystate = yydgoto[{}] = {}", reduction, self.tables.yydgoto[lhs as usize]);
                    self.tables.yydgoto[lhs as usize] as usize
                };
            debug!(
                "        after reduction, shifting from state {} to state {}",
                self.yystate, next_state
            );

            self.yystate = next_state;
            self.state_stack.push(next_state);
        }
    }

    fn do_defreds(&mut self, ctx: &mut AppContext) -> bool {
        // Check for default reductions.
        let mut any = false;
        loop {
            let defred = self.tables.yydefred[self.yystate];
            if defred != 0 {
                // debug!("    default reduction: yyn={}", defred);
                self.yyreduce(defred as usize, ctx);
                any = true;
            } else {
                // debug!("    no more defreds");
                return any;
            }
        }
    }

    fn try_shift(&mut self, token: u32, lval: SymbolValue) -> bool {
        // Check to see if there is a SHIFT action for this (state, token).
        let shift = self.tables.yysindex[self.yystate] as i16;
        if shift != 0 {
            let yyn = shift + (token as i16);
            assert!(yyn >= 0);
            assert!(self.tables.yycheck[yyn as usize] as i16 == token as i16);
            let next_state = self.tables.yytable[yyn as usize] as i16;
            debug!(
                "state {}, shifting to state {}, pushing lval {:?}",
                self.yystate, next_state, lval
            );
            assert!(next_state >= 0);
            self.yystate = next_state as usize;
            self.state_stack.push(self.yystate);
            self.value_stack.push(lval); // <-- lval is consumed
            true
        } else {
            false
        }
    }

    // Check to see if there is a REDUCE action for this (state, token).
    fn try_reduce(&mut self, ctx: &mut AppContext, token: u32) -> bool {
        let red = self.tables.yyrindex[self.yystate] as i16;
        if red != 0 {
            let yyn = red + (token as i16);
            debug!("    yyn={}", yyn);
            assert!(self.tables.yycheck[yyn as usize] as i16 == token as i16);
            debug!("    reducing by {}", red);
            let rr = self.tables.yytable[yyn as usize] as usize;
            self.yyreduce(rr, ctx);
            true
        } else {
            false
        }
    }

    /// Advances the state of the parser by reporting a new token to the parser.
    ///
    /// Calling this method is the equivalent of returning a token (other than `YYEOF`) from a `yylex()`
    /// function in a YACC parser.
    pub fn push_token(
        &mut self,
        ctx: &mut AppContext,
        token: u32,
        lval: SymbolValue,
    ) -> PushTokenResult {
        assert!(self.state_stack.len() > 0);

        debug!("");
        debug!(
            "state {}, reading {} ({}) lval {:?}, state_stack = {:?}",
            self.yystate, token, self.tables.yyname[token as usize], lval, self.state_stack
        );
        debug!("value_stack = {:?}", self.value_stack);

        if self.try_shift(token, lval) {
            self.do_defreds(ctx);
            return PushTokenResult::Ok;
        }

        if self.try_reduce(ctx, token) {
            self.do_defreds(ctx);
            return PushTokenResult::Ok;
        }

        // If there is neither a shift nor a reduce action defined for this (state, token),
        // then we have encountered a syntax error.

        debug!("syntax error!  token is not recognized in this state.");
        return PushTokenResult::SyntaxError;
    }

    /// Pushes the final "end of input" token into the state machine, and checks whether the grammar has
    /// accepted or rejected the sequence of tokens.
    ///
    /// Calling this method is the equivalent of returning `YYEOF` from a `yylex()` function in a YACC parser.
    pub fn finish(&mut self, ctx: &mut AppContext) -> FinishParseResult<SymbolValue> {
        assert!(self.state_stack.len() > 0);

        // let mut yystate = self.state_stack[self.state_stack.len() - 1] as usize;

        debug!("");
        debug!(
            "push_end: yystate={:?}  state_stack = {:?}",
            self.yystate, self.state_stack
        );

        self.try_reduce(ctx, 0);
        self.do_defreds(ctx);

        if self.value_stack.len() == 1 {
            debug!("accept");
            let final_lval = self.value_stack.pop().unwrap();
            return FinishParseResult::Accepted(final_lval);
        }

        debug!(
            "done with all reductions.  yystate={:?}  state_stack={:?}",
            self.yystate, self.state_stack
        );

        // If there is neither a shift nor a reduce action defined for this (state, token),
        // then we have encountered a syntax error.

        debug!("syntax error!  token is not recognized in this state.");
        return FinishParseResult::SyntaxError;
    }
}
